import xbmc
import os
import pickle
import threading
from kodipopcorntime import plugin
from contextlib import contextmanager, closing
from kodipopcorntime.platform import PLATFORM

if PLATFORM["os"] == "android":
    from dumbdbm import _Database
    _old_chmod = _Database._chmod
    def _new_chmod(*args, **kwargs):
        try:
            return _old_chmod(*args, **kwargs)
        except OSError: # on FAT32 this will fail
            pass
    _Database._chmod = _new_chmod

LOCKS = {}

CACHE_DIR = xbmc.translatePath("special://profile/addon_data/%s/cache" % plugin.id)
if not os.path.exists(CACHE_DIR):
    os.makedirs(CACHE_DIR)

@contextmanager
def shelf(filename, ttl=0):
    import shelve
    filename = os.path.join(CACHE_DIR, filename)
    with LOCKS.get(filename, threading.RLock()):
        with closing(shelve.open(filename, writeback=True)) as d:
            import time
            if not d:
                d.update({
                    "created_at": time.time(),
                    "data": {},
                })
            elif ttl > 0 and (time.time() - d["created_at"]) > ttl:
                d["data"] = {}
            yield d["data"]


def cached_route(*args, **kwargs):
    from functools import wraps
    def cached(fn):
        @wraps(fn)
        def _fn(*a, **kwds):
            import hashlib
            basename = "kodipopcorntime.route.%s" % hashlib.sha1(plugin.request.path).hexdigest()
            with shelf(basename, ttl=kwargs.get("ttl") or 0) as result:
                if not result.get("value"):
                    ret = fn(*a, **kwds)
                    import types
                    if isinstance(ret, types.GeneratorType):
                        ret = list(ret)
                    result["value"] = ret
                if kwargs.get("content_type"):
                    plugin.set_content(kwargs.get("content_type"))
                return result["value"]
        return _fn
    if len(args) == 1 and callable(args[0]):
        return cached(args[0])
    return cached

SUBTYPES = ['.srt']

def subtitle(url):
    import urllib
    import zipfile

    if url == '' or not type(url) is str:
        return None

    name = os.path.join(CACHE_DIR, 'temp.zip')
    try:
        name, hdrs = urllib.urlretrieve(url, name)
        z = zipfile.ZipFile(name)
    except IOError, e:
        return None
    except zipfile.error, e:
        return None

    for each in z.namelist():
        if os.path.splitext(each)[1] in SUBTYPES:
            z.extract(each, CACHE_DIR)
            break
    z.close()
    os.unlink(name)
    return os.path.join(CACHE_DIR, each)

def clear_subtitle(file):
    name = os.path.basename(file)
    if os.path.splitext(name)[1] in SUBTYPES:
        os.unlink(os.path.join(CACHE_DIR, name))
